#!/usr/bin/env bash
CLI_PACKED='true'

#
# Table Of Content
#
# commands:
#     cli::loader
#     cli::pack
#     cli::self_test
#     cli::find::commands
#     cli::find::groups
# 
# references:
#     cli_emit

#
# Loader
#
set +m
shopt -s lastpipe
set -e
set -u
shopt -s globstar
shopt -s extglob
shopt -s nullglob
help() { echo "Unexpected missing 'help' in ${BASH_SOURCE[1]}."; }
self_test() { return; }
declare -- CLI_REFLECT=""
cli::escape_args_then_call_as () 
{ 
    local user=$1;
    shift;
    local -a args;
    for i in "$@";
    do
        args+=($(printf %q "${i}"));
    done;
    sudo su "${user}" -c "${args[*]}"
}
cli::export () 
{ 
    cli::export_variables "$@";
    cli::export_functions "$@"
}
cli::export_functions () 
{ 
    local glob;
    for i in "$@";
    do
        glob+="${i}::";
    done;
    while read keyword flags name; do
        if [[ "${name}" == ${glob}* ]]; then
            declare -f "${name}";
        fi;
    done < <(declare -F)
}
cli::export_variables () 
{ 
    local -u glob;
    for i in "$@";
    do
        glob+="${i}_";
    done;
    for i in $(eval echo "\${!${glob}@}");
    do
        declare -p "${i}";
    done
}
cli::import () 
{ 
    if [[ ${CLI_PACKED:=} == 'true' ]]; then
        echo "cli::shim ${1//_/-} ${@:2}";
    else
        if [[ ${CLI_REFLECT:=} == 'true' ]]; then
            echo $@ > /dev/stderr;
        fi;
        "$@";
    fi
}
cli::load () 
{ 
    if ! declare -F initialize > /dev/null; then
        help | clidsl tokenize | clidsl parse | clidsl emit | source /dev/stdin;
        for i in "$@";
        do
            if [[ "${i}" == '---declare-prolog' ]]; then
                declare -f initialize;
                exit;
            fi;
        done;
    fi;
    for i in "$@";
    do
        if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then
            help;
            exit;
        else
            if [[ "${i}" == '--self-test' ]]; then
                self_test;
                exit;
            else
                if [[ "${i}" == '---declare-prolog' ]]; then
                    exit;
                fi;
            fi;
        fi;
    done;
    unset i;
    : ${arg_run_as:=};
    local -a args=("$@");
    initialize "$@";
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}";
    else
        unset arg_run_as;
        unset arg_self_test;
        unset arg_help;
        unset args;
        main;
    fi
}
cli::source () 
{ 
    if [[ "${arg_dry_run:=}" == "true" ]]; then
        while read; do
            echo ${REPLY};
        done;
    else
        if [[ "${arg_debug:=}" == "true" ]]; then
            set -x;
        fi;
        source /dev/stdin;
        if [[ "${arg_debug:=}" == "true" ]]; then
            set +x;
        fi;
    fi
}

#
# Commands
#
cli::loader() (
    
    help() {
        cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
    }
    
    main() {
    
        # supress background processes from displaying their exit status upon completion.
        # see https://mywiki.wooledge.org/BashFAQ/024
        echo 'set +m'
    
        # run the last segment of a pipeline in the current execution process, not a subshell.
        # see https://mywiki.wooledge.org/BashFAQ/024
        echo 'shopt -s lastpipe'
    
        echo 'set -e'
        echo 'set -u' 
        # set -o pipefail
    
        # If set, the pattern ‘**’ used in a filename expansion context will match all 
        # files and zero or more directories and subdirectories. If the pattern is followed 
        # by a ‘/’, only directories and subdirectories match.
        echo 'shopt -s globstar'
    
        # If the extglob shell option is enabled using the shopt builtin, 
        # several extended pattern matching operators are recognized. 
        echo 'shopt -s extglob'
    
        # If set, Bash allows filename patterns which match 
        # no files to expand to a null string, rather than themselves.
        echo 'shopt -s nullglob' 
    
        echo "help() { echo "Unexpected missing 'help' in ${BASH_SOURCE[1]}."; }"
        echo "self_test() { return; }"
        if [[ ${CLI_REFLECT:=} == 'true' ]]; then
            echo "initialize() { return; }"
        fi
        cli::export cli
    }
    
    cli::export_functions() {
        local glob
    
        for i in "$@"; do 
            glob+="${i}::"
        done
    
        while read keyword flags name; do
            if [[ "${name}" == ${glob}* ]]; then
                declare -f "${name}"
            fi
        done < <(declare -F)
    }
    
    cli::export_variables() {
        local -u glob
    
        for i in "$@"; do 
            glob+="${i}_"; 
        done
    
        for i in $(eval echo "${!${glob}@}"); do
            declare -p "${i}"
        done
    }
    
    cli::export() {
        cli::export_variables "$@"
        cli::export_functions "$@"
    }
    
    cli::import() {
        if [[ ${CLI_PACKED:=} == 'true' ]]; then
            # $0 may be a file name (e.g. cli_emit), convert it to a command name
            echo "cli::shim ${1//_/-} ${@:2}"
        else
            if [[ ${CLI_REFLECT:=} == 'true' ]]; then
                echo $@ > /dev/stderr
            fi
            "$@"
        fi
    }
    
    # dry run support
    cli::source() {
        if [[ "${arg_dry_run:=}" == "true" ]]; then 
            # removes extra spaces which is typically what we want
            while read; do echo ${REPLY}; done
        else
            if [[ "${arg_debug:=}" == "true" ]]; then set -x; fi
            source /dev/stdin
            if [[ "${arg_debug:=}" == "true" ]]; then set +x; fi
        fi
    }
    
    cli::escape_args_then_call_as() {
        local user=$1
        shift
    
        local -a args
        for i in "$@"; do
            args+=( $(printf %q "${i}") )
        done
    
        sudo su "${user}" -c "${args[*]}"
    }
    
    cli::load() {
    
        # source 'initialize()' if not already defined
        if ! declare -F initialize > /dev/null; then
            help             | clidsl tokenize             | clidsl parse             | clidsl emit             | source /dev/stdin
    
            for i in "$@"; do
                # prolog for inclusion in a packed command
                if [[ "${i}" == '---declare-prolog' ]]; then
                    declare -f initialize; exit
                fi
            done
        fi
    
        # implement known flags before verifying arguments
        for i in "$@"; do
            if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then 
                help; exit
            elif [[ "${i}" == '--self-test' ]]; then
                self_test; exit
            elif [[ "${i}" == '---declare-prolog' ]]; then
                exit
            fi
        done
        unset i
    
        # declare well known variables
        : ${arg_run_as:=}
    
        local -a args=( "$@" )
        initialize "$@"
    
        # implement well known features
        if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
            cli::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"
        else
            # clean up known arguments
            unset arg_run_as
            unset arg_self_test
            unset arg_help
            unset args
            main
        fi
    }
    
    initialize() {
        while (( $# > 0 )); do
            case $1 in
                '-h') arg_help=true ;;
                '--help') arg_help=true ;;
                *) echo "Unexpected argument $1."; exit 1 ;;
            esac
    
            shift
        done
    }
    
    cli::load "$@"
)
cli::pack() (
    initialize () 
    { 
        declare -g arg_help="";
        declare -g arg_dry_run="";
        declare -g arg_self_test="";
        declare -g arg_dir="";
        declare -g arg_dir="";
        declare -g arg_output="";
        declare -g arg_name="";
        declare -g arg_output="";
        declare -g arg_help="";
        declare -g arg_name="";
        arg_output=""."";
        arg_self_test=false;
        arg_help=false;
        arg_dry_run=false;
        while (( $# > 0 )); do
            case "$1" in 
                '--help')
                    arg_help=true
                ;;
                '--dry-run')
                    arg_dry_run=true
                ;;
                '--self-test')
                    arg_self_test=true
                ;;
                '--dir')
                    arg_dir="${2:-}";
                    shift
                ;;
                '-d')
                    arg_dir="${2:-}";
                    shift
                ;;
                '--output')
                    arg_output="${2:-}";
                    shift
                ;;
                '-n')
                    arg_name="${2:-}";
                    shift
                ;;
                '-o')
                    arg_output="${2:-}";
                    shift
                ;;
                '-h')
                    arg_help=true
                ;;
                '--name')
                    arg_name="${2:-}";
                    shift
                ;;
                *)
                    echo "Unexpected argument '$1'.";
                    exit 1
                ;;
            esac;
            if (( $# > 0 )); then
                shift;
            fi;
        done;
        if [[ -z "${arg_dir}" ]]; then
            echo "Missing required argument '--dir'.";
            exit 1;
        fi;
        if [[ -z "${arg_name}" ]]; then
            echo "Missing required argument '--name'.";
            exit 1;
        fi
    }
    source /dev/stdin < <(cli::import cli_emit)
    
    help() {
        cat << EOF
Command
    cli pack

Summary
    Package a group of commands into a into a single file.
    
Description
    Recursively discovers cli commands developed as individual files
    and hosted in a specified directory, and packages them into a 
    single file. 
    
    All commands that import or export logic must start with the 
    following lines in order to define 'cli::import' and 'cli::export':
    
        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)

    A command must use 'cli::import' to abstract the paths it sources and,
    if a library, 'cli::export' to print functions and variables that other 
    commands will source. 

    For example, imagine a cli 'area' with command 'sqaure' and a library 
    hosted in a command '.dir'. The command '.dir' will use 'cli::export' 
    to print all functions and variables that start with the prefix 'area::' 
    or 'AREA_' respectively like this:

        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)
        main() { cli::export 'area'; }
        AREA_PI='3.14159'
        area::multiply() { echo "\$1 * \$2" | bc -l; }
        cli::load "\$@"
    
    The command 'sqaure' would import '.dir' like this:

        #!/usr/bin/env bash
        source /dev/stdin < <(cli loader)
        source /dev/stdin < <(cli::import area .dir)
        main() { echo \$(area::multiply \${arg_side} \${arg_side}); }
        cli::load "\$@"

Arguments
    --dir -d        [Required] : Root directory hosting groups of commands
                                 which are to be packaged into a single cli.
    --name -n       [Required] : Name of the cli.
    --output -o                : Ouput directory file. Default: ".".

Global Arguments
    --help -h           [Flag] : Show this message and exit.
    --self-test         [Flag] : Runs a self test.
    --dry-run           [Flag] : Show the commands that would be packed.
EOF
    }
    
    main() (
        if ${arg_dry_run}; then
            table_of_content
        else
            local path="${arg_output}/${arg_name}"
            emit > "${path}"
            chmod a+x "${path}"
        fi
    )
    
    find_commands() {
        cli find commands --recursive --dir "${arg_dir}"
    }
    
    find_references() {
        find_commands         | while read; do             CLI_REFLECT='true' "${arg_dir}${REPLY}" -h 2>&1 >/dev/null;           done         | sort -u
    }
    
    table_of_content() {
        echo 'commands:'
        find_commands         | while read; do echo "$(emit_command_name ${REPLY})"; done         | sed 's/^/    /'
        echo
    
        echo 'references:'
        find_references         | while read; do echo "$(emit_library_name ${REPLY})"; done         | sed 's/^/    /'
    }
    
    emit() {
        echo #!/usr/bin/env bash
        echo "CLI_PACKED='true'"
        echo
    
        # toc
        table_of_content | sed 's/^/# /' | emit_section 'Table Of Content'
    
        # loader
        cli loader | emit_section 'Loader'
    
        # "${arg_dir}${REPLY}" '--declare-initialize'
    
        # commands
        find_commands         | while read; do             cat <("${arg_dir}${REPLY}" '---declare-prolog')                 <(cat "${arg_dir}${REPLY}" | sed 1,2d | emit::file)             | emit::subproc "$(emit_command_name "${REPLY}")";           done         | emit_section 'Commands'
    
        # libraries
        find_references         | while read; do             ${REPLY} | emit::function "$(emit_library_name "${REPLY}")";           done         | emit_section 'Libraries'
    
        # shim
        cli .shim | emit_section 'Shim'
    
        echo cli::shim "${arg_name}" "$@"
    }
    
    emit_section() {
        echo #
        echo # $1
        echo #
        while read -r; do echo "${REPLY}"; done
        echo
    }
    
    emit_library_name() {
        echo "${1/ /::}"
    }
    
    emit_command_name() {
        # e.g. given a cli 'area' with command './circle' -> 'area::circle'
        local name="${1#./}"
        echo "${arg_name}::${name////::}"
    }
    
    self_test() (
        return
    )
    
    cli::load "$@"
)
cli::self_test() (
    initialize () 
    { 
        declare -g arg_help="";
        declare -g arg_dry_run="";
        declare -g arg_dir="";
        declare -g arg_help="";
        arg_help=false;
        arg_dry_run=false;
        while (( $# > 0 )); do
            case "$1" in 
                '--help')
                    arg_help=true
                ;;
                '--dry-run')
                    arg_dry_run=true
                ;;
                '--dir')
                    arg_dir="${2:-}";
                    shift
                ;;
                '-h')
                    arg_help=true
                ;;
                *)
                    echo "Unexpected argument '$1'.";
                    exit 1
                ;;
            esac;
            if (( $# > 0 )); then
                shift;
            fi;
        done
    }
    
    help() {
        cat << EOF
Command
    cli self-test

Summary
    Run a self test for every command. 
    
Description
    Commands are found via recursive search starting at '--dir'.
    Those commands are then invoked with the flag '--self-test'.
    If all test succeed, the exit code is 0, otherwise 1.

Arguments
    --dir                   : The directory to start searching for commands.

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --dry-run        [Flag] : Show the commands that would be run.
EOF
    }
    
    report() {
        local command="$1"
    
        # interpret no output as a success
        if ! read result; then
            return
        fi
    
        # interpret any output as a failure
        exit_code=1
        echo "${command}"
        cat <(echo ${result}) - | sed 's/^/>   /'
    }
    
    main() {
        local exit_code=0
    
        # search for commands starting at --dir
        cli find commands --dir "${arg_dir}" --recursive | {
            while read command; do 
    
                if $arg_dry_run; then
                    echo "${command} --self-test"
                    continue
                fi
    
                # execute each command's self test
                "${command}" --self-test 2>&1 | report "${command}"
            done
        }
    
        exit "${exit_code}"
    }
    
    cli::load "$@"
)
cli::find::commands() (
    initialize () 
    { 
        declare -g arg_help="";
        declare -g arg_base_dir="";
        declare -g arg_self_test="";
        declare -g arg_recursive="";
        declare -g arg_all="";
        declare -g arg_recursive="";
        declare -g arg_dir="";
        declare -g arg_dir="";
        declare -g arg_help="";
        arg_base_dir=""."";
        arg_all=false;
        arg_self_test=false;
        arg_help=false;
        arg_recursive=false;
        while (( $# > 0 )); do
            case "$1" in 
                '--help')
                    arg_help=true
                ;;
                '--base-dir')
                    arg_base_dir="${2:-}";
                    shift
                ;;
                '--self-test')
                    arg_self_test=true
                ;;
                '-r')
                    arg_recursive=true
                ;;
                '--all')
                    arg_all=true
                ;;
                '--recursive')
                    arg_recursive=true
                ;;
                '--dir')
                    arg_dir="${2:-}";
                    shift
                ;;
                '-d')
                    arg_dir="${2:-}";
                    shift
                ;;
                '-h')
                    arg_help=true
                ;;
                *)
                    echo "Unexpected argument '$1'.";
                    exit 1
                ;;
            esac;
            if (( $# > 0 )); then
                shift;
            fi;
        done
    }
    
    help() {
    cat << EOF
Command
    cli find commands

Arguments
    --dir -d                : Directory to search.
    --recursive  -r  [Flag] : Recurse.
    --all            [Flag] : Include commands beginning with dot.
    --base-dir              : Internal. The base directory. Default: ".".

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.
EOF
    }
    
    main() (
        local glob='*'
        if ${arg_all}; then
            glob='* .[^.]*'
        fi
    
        cd "${arg_dir}"
        for entry in ${glob}; do
            if [ -f "${entry}" ] && [ -x "${entry}" ]; then
                echo "${arg_base_dir}/${entry}"
            fi
        done
    
        if [[ ! "${arg_recursive}" == 'true' ]]; then
            exit
        fi
    
        for entry in *; do
            if [ -d "${entry}" ] && [ -x "${entry}" ]; then
                cli find commands                 --dir "$(pwd)/${entry}"                 --base-dir "${arg_base_dir}/${entry}"                 --recursive
            fi
        done
    )
    
    cli::load "$@"
)
cli::find::groups() (
    initialize () 
    { 
        while (( $# > 0 )); do
            case "$1" in 
                *)
                    echo "Unexpected argument '$1'.";
                    exit 1
                ;;
            esac;
            if (( $# > 0 )); then
                shift;
            fi;
        done
    }
    
    main() {
            
        local path='.'
        for i in "$@"; do
            path="${path}/${i}"
        done
    
        (
            cd "$path"
            for entry in *; do 
                [ -d "$entry" ] && [ -x "$entry" ] && echo $entry
            done
        )
    }
    
    cli::load "$@"
)

#
# Libraries
#
cli_emit() {
    declare -- EMIT_TAB="    "
    emit::assign () 
    { 
        echo "$1=$2"
    }
    emit::assign_string () 
    { 
        emit::assign "$1" ""$2""
    }
    emit::call () 
    { 
        echo -n "$1";
        for i in "${@:2}";
        do
            echo -n " ";
            echo -n ""$i"";
        done;
        echo
    }
    emit::case () 
    { 
        emit::case "'$1'"
    }
    emit::case_default () 
    { 
        emit::case_raw '*'
    }
    emit::case_inline () 
    { 
        read;
        echo "'$1') $REPLY ;;"
    }
    emit::case_noop () 
    { 
        echo "'$1') ;;"
    }
    emit::case_raw () 
    { 
        echo "$1)";
        emit::indented;
        echo ";;"
    }
    emit::case_statement () 
    { 
        echo "case "$1" in";
        emit::indented;
        echo "esac"
    }
    emit::comment () 
    { 
        echo "# $1"
    }
    emit::declare () 
    { 
        echo -n "declare $1 $2";
        if (( $# == 3 )); then
            echo -n "="$3"";
        fi;
        echo
    }
    emit::declare_global () 
    { 
        emit::declare -g $1 "${2-}"
    }
    emit::error () 
    { 
        echo echo ""$1"";
        echo "exit 1"
    }
    emit::file () 
    { 
        while read -r || [ -n "${REPLY}" ]; do
            echo "${REPLY}";
        done
    }
    emit::function () 
    { 
        echo "$1() {";
        emit::indented;
        echo "}"
    }
    emit::if () 
    { 
        echo "if $1; then";
        emit::indented;
        echo "fi"
    }
    emit::if_empty () 
    { 
        emit::if "[[ -z "${$1}" ]]"
    }
    emit::indented () 
    { 
        local regex='<< ([A-Z]+)';
        local eof=;
        while read; do
            if [[ "${REPLY}" =~ ${regex} ]]; then
                echo "${EMIT_TAB}${REPLY}";
                eof=${BASH_REMATCH[1]};
                while read -r; do
                    echo "${REPLY}";
                    if [[ "${REPLY}" == "${eof}" ]]; then
                        break;
                    fi;
                done;
                continue;
            fi;
            echo "${EMIT_TAB}${REPLY}";
        done
    }
    emit::inline () 
    { 
        local delimiter=;
        while read; do
            echo -n "${delimiter}${REPLY}";
            delimiter='; ';
        done;
        echo
    }
    emit::new_line () 
    { 
        echo
    }
    emit::shift () 
    { 
        echo "shift"
    }
    emit::subproc () 
    { 
        echo "$1() (";
        emit::indented;
        echo ")"
    }
    emit::variable_required () 
    { 
        echo ": ${$1?$2}"
    }
    emit::while () 
    { 
        echo "while $1; do";
        emit::indented;
        echo "done"
    }
}

#
# Shim
#
declare -r CLI_ARG_CHAR_GLOB="[a-zA-Z0-9-]"
declare -r CLI_DSL_ARG_NAME_GLOB="-*"
declare -r CLI_ARG_DIR_ENTRY_GLOB="?([.])+([a-zA-Z0-9-])"
cli::shim () 
{ 
    local path=;
    local delimiter=;
    if [[ ! "${CLI_PACKED}" == 'true' ]]; then
        delimiter='/';
        path=${1?"First shim argument should be /path/to/command"};
        shift;
    else
        delimiter='::';
    fi;
    while (( $# > 0 )); do
        if [[ "$1" == ${CLI_DSL_ARG_NAME_GLOB} ]]; then
            break;
        fi;
        if [[ ! "$1" == $CLI_ARG_DIR_ENTRY_GLOB ]]; then
            echo "Unexpected command name/group '$1' does not match '$CLI_ARG_DIR_ENTRY_GLOB'.";
            exit 1;
        fi;
        if [[ -n "${path}" ]]; then
            path="${path}${delimiter}";
        fi;
        path="${path}${1//-/_}";
        shift;
    done;
    if declare -F "$path" > /dev/null; then
        "${path}" "$@";
    else
        if [[ -f "${path}" ]] && [[ -x "${path}" ]]; then
            "${path}" "$@";
        else
            if [[ -d "${path}" ]]; then
                production=${PRODUCTION_ARG_DIR};
            else
                echo "Unexpected path '${path}' is neither a function, executable file, or directory.";
                exit 1;
            fi;
        fi;
    fi
}

cli::shim cli "$@"
