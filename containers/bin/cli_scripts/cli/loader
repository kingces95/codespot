#!/usr/bin/env bash
# source /dev/stdin < <(cli loader)

help() {
    cat << EOF
Command
    cli loader

Summary
    Prints the source for function 'cli::load'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

main() {

    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    echo 'set -e'
    echo 'set -u' 
    # set -o pipefail

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    if [[ ${CLI_REFLECT:=} == 'true' ]]; then
        echo "initialize() { return; }"
    fi
    cli::export cli
}

cli::export_functions() {
    local glob

    for i in "$@"; do 
        glob+="${i}::"
    done

    while read keyword flags name; do
        if [[ "${name}" == ${glob}* ]]; then
            declare -f "${name}"
        fi
    done < <(declare -F)
}

cli::export_variables() {
    local -u glob

    for i in "$@"; do 
        glob+="${i}_"; 
    done

    for i in $(eval echo "\${!${glob}@}"); do
        declare -p "${i}"
    done
}

cli::export() {
    cli::export_variables "$@"
    cli::export_functions "$@"
}

cli::import() {
    if [[ ${CLI_PACKED:=} == 'true' ]]; then
        # $0 may be a file name (e.g. cli_emit), convert it to a command name
        echo "cli::shim ${1//_/-} ${@:2}"
    else
        if [[ ${CLI_REFLECT:=} == 'true' ]]; then
            echo $@ > /dev/stderr
        fi
        "$@"
    fi
}

# dry run support
cli::source() {
    if [[ "${arg_dry_run:=}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:=}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:=}" == "true" ]]; then set +x; fi
    fi
}

cli::escape_args_then_call_as() {
    local user=$1
    shift

    local -a args
    for i in "$@"; do
        args+=( $(printf %q "${i}") )
    done

    sudo su "${user}" -c "${args[*]}"
}

cli::load() {

    # source 'initialize()' if not already defined
    if ! declare -F initialize > /dev/null; then
        help \
            | clidsl tokenize \
            | clidsl parse \
            | clidsl emit \
            | source /dev/stdin

        for i in "$@"; do
            # prolog for inclusion in a packed command
            if [[ "${i}" == '---declare-prolog' ]]; then
                declare -f initialize; exit
            fi
        done
    fi

    # implement known flags before verifying arguments
    for i in "$@"; do
        if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then 
            help; exit
        elif [[ "${i}" == '--self-test' ]]; then
            self_test; exit
        elif [[ "${i}" == '---declare-prolog' ]]; then
            exit
        fi
    done
    unset i

    # declare well known variables
    : ${arg_run_as:=}

    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        cli::escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"
    else
        # clean up known arguments
        unset arg_run_as
        unset arg_self_test
        unset arg_help
        unset args
        main
    fi
}

initialize() {
    while (( $# > 0 )); do
        case $1 in
            '-h') arg_help=true ;;
            '--help') arg_help=true ;;
            *) echo "Unexpected argument $1."; exit 1 ;;
        esac

        shift
    done
}

cli::load "$@"