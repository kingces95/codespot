#!/usr/bin/env bash
. $(dirname ${BASH_SOURCE})/../../cli.sh

help() {
util::unindent << EOF
    Command
        cli dsl help parse

    Description
        Read command help tokens from stdin and emit productions to stdout 
        one per line in the form:

            key production_id production_name [identifier]

        The productions harvested from a command's help are designed to
        be joined with productions harvested from the parsing of the 
        command line arguments to simplify validating the arguments
        against the help metadata. The join is constructed by
        mergeing the streams of production tokens and sorting them by 
        'key' and then by 'production_id'. In this way, if PRODUCTION_HELP_NAME
        appears before PRODUCTION_ARG_NAME, then the argument is expected,
        otherwise it is unexpected.

    Arguments
        --file                  : The file to report is being parsed if an error occurs.

    Global Arguments
        --help -h               : Show this message and exit.
        --self-test             : Runs a self test.

    Examples
        Parse the sample help.
            cli dsl help sample -h | cli dsl help tokenize | cli dsl help parse
EOF
}

declare line
declare word
declare token
declare token_name
declare identifier
declare arg_name='.'

main() {

    START() {
        ARGUMENTS
    }

    ARGUMENTS() {
        parser::read_token

        while (( token != TOKEN_EOF )); do
            ARGUMENT
        done
    }

    ARGUMENT() {
        parser::assert_token_is $TOKEN_NAME
    
        arg_name=${identifier}
        parser::yield ${PRODUCTION_HELP_NAME} ${identifier}
        parser::read_token

        if (( token == TOKEN_ALIAS )); then
            ALIAS
        fi

        if (( token == TOKEN_REQUIRED )); then
            REQUIRED
        fi

        ATTRIBUES
    }

    ATTRIBUES() {
        while true; do
            if (( token == TOKEN_DEFAULT )); then
                DEFAULT
            elif (( token == TOKEN_ALLOWED_VALUES )); then
                ALLOWED_VALUES
            else
                break
            fi
       done
    }

    ALIAS() {
        parser::yield ${PRODUCTION_HELP_ALIAS} ${identifier}
        parser::read_token
    }

    REQUIRED() {
        parser::yield ${PRODUCTION_HELP_REQUIRED}
        parser::read_token
    }

    DEFAULT() {
        parser::read_token ${TOKEN_VALUE_PERIOD}
        parser::yield ${PRODUCTION_HELP_DEFAULT} "${identifier}"
        parser::read_token
    }

    ALLOWED_VALUES() {
        parser::yield ${PRODUCTION_HELP_ALLOWED} "${identifier}"

        while true; do
            parser::read_token $TOKEN_VALUE_COMMA $TOKEN_VALUE_PERIOD

            if (( token == TOKEN_VALUE_COMMA )); then
                parser::yield ${PRODUCTION_HELP_ALLOWED_VALUE} "${identifier}"

            elif (( token == TOKEN_VALUE_PERIOD )); then
                parser::yield ${PRODUCTION_HELP_ALLOWED_VALUE} "${identifier}"
                parser::yield ${PRODUCTION_HELP_ALLOWED_END}
                parser::read_token
                break
            fi
        done
    }

    START
}

test() {
    cd "$(dirname ${BASH_SOURCE})"

    "./sample" -h \
        | "./tokenize" \
        | "./parse" \
        | assert::pipe_eq \
            'run-as 3 PRODUCTION_HELP_NAME run-as' \
            'fruit 3 PRODUCTION_HELP_NAME fruit' \
            'fruit 5 PRODUCTION_HELP_DEFAULT banana' \
            'fruit 10 PRODUCTION_HELP_ALLOWED' \
            'fruit 11 PRODUCTION_HELP_ALLOWED_VALUE orange' \
            'fruit 11 PRODUCTION_HELP_ALLOWED_VALUE banana' \
            'fruit 12 PRODUCTION_HELP_ALLOWED_END' \
            'debug 3 PRODUCTION_HELP_NAME debug' \
            'debug 4 PRODUCTION_HELP_ALIAS d' \
            'debug 9 PRODUCTION_HELP_REQUIRED' \
            'help 3 PRODUCTION_HELP_NAME help' \
            'help 4 PRODUCTION_HELP_ALIAS h' 
}

util::main "$@"