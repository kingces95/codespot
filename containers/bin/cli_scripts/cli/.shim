#!/usr/bin/env bash
# source /dev/stdin < <(cli loader)

help() {
    cat << EOF
Command
    cli .shim

Description
    Accepts raw command line arguments where the \$1 is the path to the
    cli tool directory followed by path segments which combine to form
    the relative path from the cli directory to an executable file (command) 
    or a directory (group). If a file, then the file is executed and 
    passed the remaining arguments. If a directory, then a listing of
    the commands in that group is displayed.

Global Arguments
    --self-test         [Flag] : Runs a self test over all commands.
EOF
}

readonly CLI_ARG_CHAR_GLOB="[a-zA-Z0-9-]"
readonly CLI_DSL_ARG_NAME_GLOB="-*"
readonly CLI_ARG_DIR_ENTRY_GLOB="?([.])+(${CLI_ARG_CHAR_GLOB})"

cli::shim() {
    local path=
    local delimiter=

    # test for development environment
    if [[ ! "${CLI_PACKED}" == 'true' ]]; then
        # use filesystem to resolve command
        delimiter='/'

        # first argument is the base directory where commands are under development
        path=${1?"First shim argument should be /path/to/command"}
        shift
    else
        # use namespaces to resolve command
        delimiter='::'
    fi

    # bind to command path
    while (( $# > 0 )); do

        # stop concatenating path segments once the first argument is found (e.g. --foo)
        if [[ "$1" == ${CLI_DSL_ARG_NAME_GLOB} ]]; then 
            break
        fi

        # ensure uniformity of group names (e.g. foo-bar, not foo_bar)
        if [[ ! "$1" == $CLI_ARG_DIR_ENTRY_GLOB ]]; then
            echo "Unexpected command name/group '$1' does not match '$CLI_ARG_DIR_ENTRY_GLOB'."
            exit 1
        fi

        # add path delimiter
        if [[ -n "${path}" ]]; then
            path="${path}${delimiter}"
        fi

        path="${path}${1//-/_}"
        shift
    done

    # bind to function
    if declare -F "$path" > /dev/null; then
        "${path}" "$@"

    # bind to file (development)
    elif [[ -f "${path}" ]] && [[ -x "${path}" ]]; then
        "${path}" "$@"

    # bind to directory (development)
    elif [[ -d "${path}" ]]; then
        production=${PRODUCTION_ARG_DIR}

    # bind fail
    else
        echo "Unexpected path '${path}' is neither a function, executable file, or directory."
        exit 1
    fi
}

if (( "$#" == 0 )); then
    declare -p CLI_ARG_CHAR_GLOB
    declare -p CLI_DSL_ARG_NAME_GLOB
    declare -p CLI_ARG_DIR_ENTRY_GLOB
    declare -f cli::shim
else
    cli::shim "$@"
fi