#!/usr/bin/env bash

help() {
    cat << EOF
Command
    cli shim

Summary
    Prints the source for function 'shim'.
    
Description

Arguments

Global Arguments
    --help -h       : Show this message and exit.
    --self-test     : Runs a self test.
EOF
}

main() {

    # supress background processes from displaying their exit status upon completion.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'set +m'

    # run the last segment of a pipeline in the current execution process, not a subshell.
    # see https://mywiki.wooledge.org/BashFAQ/024
    echo 'shopt -s lastpipe'

    echo 'set -e'
    echo 'set -u' 
    # set -o pipefail

    # If set, the pattern ‘**’ used in a filename expansion context will match all 
    # files and zero or more directories and subdirectories. If the pattern is followed 
    # by a ‘/’, only directories and subdirectories match.
    echo 'shopt -s globstar'

    # If the extglob shell option is enabled using the shopt builtin, 
    # several extended pattern matching operators are recognized. 
    echo 'shopt -s extglob'

    # If set, Bash allows filename patterns which match 
    # no files to expand to a null string, rather than themselves.
    echo 'shopt -s nullglob' 

    echo "help() { echo \"Unexpected missing 'help' in \${BASH_SOURCE[1]}.\"; }"
    echo "self_test() { return; }"
    cli::export cli
    echo "shim() { cli::shim \"\$@\"; }"
}

cli::export_functions() {
    local glob

    for i in "$@"; do 
        glob+="${i}::"
    done

    while read keyword flags name; do
        if [[ "${name}" == ${glob}* ]]; then
            declare -f "${name}"
        fi
    done < <(declare -F)
}

cli::export_variables() {
    local -u glob

    for i in "$@"; do 
        glob+="${i}_"; 
    done

    for i in $(eval echo "\${!${glob}@}"); do
        declare -p "${i}"
    done
}

cli::export() {
    cli::export_variables "$@"
    cli::export_functions "$@"
}

# dry run support
cli::source() {
    if [[ "${arg_dry_run:=}" == "true" ]]; then 
        # removes extra spaces which is typically what we want
        while read; do echo ${REPLY}; done
    else
        if [[ "${arg_debug:=}" == "true" ]]; then set -x; fi
        source /dev/stdin
        if [[ "${arg_debug:=}" == "true" ]]; then set +x; fi
    fi
}

cli::shim() {

    escape_args_then_call_as() {
        local user=$1
        shift

        local -a args
        for i in "$@"; do
            args+=( $(printf %q "${i}") )
        done

        sudo su "${user}" -c "${args[*]}"
    }

    # implement known flags before verifying arguments
    for i in "$@"; do
        if [[ "${i}" == '-h' ]] || [[ "${i}" == '--help' ]]; then 
            help; exit
        elif [[ "${i}" == '--self-test' ]]; then
            self_test; exit
        fi
    done
    unset i

    # resolve aliases, and verify arguments
    if ! declare -F initialize > /dev/null; then
        help \
            | cli dsl tokenize \
            | cli dsl parse \
            | cli dsl emit \
            | source /dev/stdin
    fi

    # declare well known variables
    : ${arg_run_as:=}

    local -a args=( "$@" )
    initialize "$@"

    # implement well known features
    if [[ -n "${arg_run_as}" ]] && [[ ! "${arg_run_as}" == "$(whoami)" ]]; then
        escape_args_then_call_as "${arg_run_as}" "$0" "${args[@]}"
    else
        # clean up known arguments
        unset arg_run_as
        unset arg_self_test
        unset arg_help
        unset args
        main
    fi
}

initialize() {
    while (( $# > 0 )); do
        case $1 in
            '-h') arg_help=true ;;
            '--help') arg_help=true ;;
            *) echo "Unexpected argument $1."; exit 1 ;;
        esac

        shift
    done
}

cli::shim "$@"