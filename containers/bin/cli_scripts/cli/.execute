#!/usr/bin/env bash
. $(dirname ${BASH_SOURCE})/cli.sh

# shift arguments including $1 into $0
BASH_ARGV0=${1?"First argument to 'execute' should be /path/to/command"}
shift

# used to debug a stage in the loader pipeline
: ${CLI_STAGE:=100}

# paths to dsl sub-scripts (e.g. cli/dsl/help/tokenize)
readonly CLI_DIR=$(util::this_dir)
readonly CLI_DSL_DIR="${CLI_DIR}/dsl"
readonly CLI_DSL_ARGS_DIR="${CLI_DSL_DIR}/args"
readonly CLI_DSL_ARGS_TOKENIZE="${CLI_DSL_ARGS_DIR}/tokenize"
readonly CLI_DSL_ARGS_PARSE="${CLI_DSL_ARGS_DIR}/parse"
readonly CLI_DSL_LOAD="${CLI_DSL_DIR}/load"
readonly CLI_DSL_PATCH="${CLI_DSL_DIR}/patch"
readonly CLI_DSL_COMPILE="${CLI_DSL_DIR}/compile"
readonly CLI_DSL_EXECUTE="${CLI_DSL_DIR}/execute"

pipe() {
    local stage="$1"
    local cmd="$2"

    if (( stage < CLI_STAGE )); then
        eval "${cmd}"
    else
        if (( stage == CLI_STAGE )); then
            eval "${cmd}" > /dev/stderr
        fi
        echo ":"
    fi
}

assert() {
    local variable=$1
    local blob=$2
    local message=$3

    if [[ ! "${variable}" == $blob ]]; then
        error "${message}"
    fi
}

error() {
    local message=$1
    echo "${message}"
    exit 1
}

main() {
    local args=()

    util::yield_args "$0" "$@" \
        | pipe 0 "${CLI_DSL_ARGS_TOKENIZE}" \
        | pipe 1 "${CLI_DSL_ARGS_PARSE}" \
        | pipe 2 "${CLI_DSL_LOAD}" \
        | pipe 3 "${CLI_DSL_PATCH}" \
        | pipe 4 "${CLI_DSL_COMPILE}" \
        | while read; do args+=( "${REPLY}" ); done

    "${args}" "${args[@]:1}"
}

test() {
    return
}

case "${1-}" in
  '--self-test') cli self-test --dir "$0" ;;
  *) main "$@"
esac