#!/usr/bin/env bash

help() {
cat << EOF
Command
    cli .execute

Description
    Accepts raw command line arguments where the \$1 is the path to the
    cli tool directory followed by path segments which combine to form
    the relative path from the cli directory to an executable file (command) 
    or a directory (group). If a file, then the file is executed and 
    passed the remaining arguments. If a directory, then a listing of
    the commands in that group is displayed.

Global Arguments
    --self-test         [Flag] : Runs a self test over all commands.
EOF
}

# shift arguments including $1 into $0
BASH_ARGV0=${1?"First argument to 'execute' should be /path/to/command"}
shift

readonly CLI_ARG_CHAR_GLOB="[a-zA-Z0-9-]"
readonly CLI_DSL_ARG_NAME_GLOB="-*"
readonly CLI_ARG_DIR_ENTRY_GLOB="?([.])+(${CLI_ARG_CHAR_GLOB})"

error() {
    local message=$1
    echo "${message}"
    exit 1
}

main() {
    local path=$0
    local args=()

    # bind to command path
    while (( $# > 0 )); do

        # stop concatenating path segments once the first argument is found (e.g. --foo)
        if [[ "$1" == ${CLI_DSL_ARG_NAME_GLOB} ]]; then 
            break
        fi

        # ensure uniformity of path segments (e.g. foo_bar, not foo-bar)
        if [[ ! "$1" == $CLI_ARG_DIR_ENTRY_GLOB ]]; then
            error "Unexpected command name '$1' does not match '$CLI_ARG_DIR_ENTRY_GLOB'."
        fi

        path="${path}/${1//-/_}"
        shift
    done

    # bind to file
    if [[ -f "${path}" ]] && [[ -x "${path}" ]]; then
        "${path}" "$@"

    # bind to directory
    elif [[ -d "${path}" ]]; then
        production=${PRODUCTION_ARG_DIR}

    # bind fail
    else
        error "Unexpected path '${path}' is neither an executable file nor a directory."
    fi
}

case "${1-}" in
    '.execute') help ;;
    *) main "$@"
esac