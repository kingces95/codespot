#!/usr/bin/env bash
source /dev/stdin < <(cli loader)
source /dev/stdin < <(cli::import clidsl .dir)
source /dev/stdin < <(cli::import cli_emit)

help() {
    cat << EOF
Command
    clidsl emit

Global Arguments
    --help -h        [Flag] : Show this message and exit.
    --self-test      [Flag] : Runs a self test.
EOF
}

# name of function which declares variables and verifies/assigns values
INITIALIZE=initialize

main() {
    local -A names # eg +=( ['--foo']='arg_foo' ) and maybe +=( ['-f']='arg_foo' )
    local -A flags # eg +=( ['arg_bar']='true' )
    local -A defaults # eg +=( ['arg_foo']='bar' )
    local -A allowed_values # eg +=( [--foo]='a b c' )
    local -a required # eg +=( '--foo' )

    local name
    local arg_name
    local switch_name
    local -a allowed_value_list

    # productions are sorted
    while read key production production_name identifier; do

        # declaration
        if (( production == CLI_DSL_PRODUCTION_NAME )); then
            name="${identifier}"
            arg_name="arg_${name//-/_}"
            switch_name="--${name}"
            names+=( [${switch_name}]="${arg_name}" )

        # alias
        elif (( production == CLI_DSL_PRODUCTION_ALIAS )); then
            names+=( [-${identifier}]="${arg_name}" )

        # defaults
        elif (( production == CLI_DSL_PRODUCTION_DEFAULT )); then
            defaults+=( [${arg_name}]="${identifier}" )

        # required
        elif (( production == CLI_DSL_PRODUCTION_REQUIRED )); then
            required+=( ${switch_name} )

        # flag
        elif (( production == CLI_DSL_PRODUCTION_FLAG )); then
            flags+=( [${arg_name}]='true' )

        # allowed
        elif (( production == CLI_DSL_PRODUCTION_ALLOWED )); then
            allowed_value_list=()
        elif (( production == CLI_DSL_PRODUCTION_ALLOWED_VALUE )); then
            allowed_value_list+=( "${identifier}" )
        elif (( production == CLI_DSL_PRODUCTION_ALLOWED_END )); then
            allowed_values+=( [${switch_name}]="${allowed_value_list[@]}" )
        fi
    done

    # code generation
    {
        emit::comment 'declarations'
        for i in "${names[@]}"; do
            emit::declare_global "${i}" 
        done
        emit::new_line

        emit::comment 'defaults'
        for i in "${!defaults[@]}"; do
            emit::assign_string "${i}" "${defaults[$i]}" 
        done
        for i in "${!flags[@]}"; do
            emit::assign "${i}" 'false'
        done
        emit::new_line

        emit::comment 'assign variables from command line arguments'
        { 
            {
                for i in "${!names[@]}"; do
                    arg_name="${names[$i]}"
                    if [[ "${flags[$arg_name]+true}" == 'true' ]]; then
                        emit::assign "${arg_name}" 'true' \
                            | emit::case_inline "${i}"
                    else
                        { emit::assign_string "${arg_name}" "\${2:-}"; emit::shift; } \
                            | emit::inline \
                            | emit::case_inline "${i}"
                    fi
                done
                emit::error "Unexpected argument '\$1'." \
                    | emit::case_default
            } | emit::case_statement "\$1"
            emit::shift | emit::if_inline "(( \$# > 0 ))"
        } | emit::while "(( \$# > 0 ))"
        emit::new_line

        emit::comment 'required'
        for i in "${required[@]}"; do
            emit::error "Missing required argument '${i}'." |
                emit::if_empty ${names[$i]}
        done
        emit::new_line

        emit::comment 'allowed values'
        for i in "${!allowed_values[@]}"; do
            {
                for j in ${allowed_values[$i]}; do
                    emit::case_noop "${j}" 
                done
                emit::error "Unexpected value '\${${names[$i]}}' for argument '${i}'." \
                    | emit::case_default
            } | emit::case_statement "\${${names[$i]}}"
        done
    } | emit::function ${INITIALIZE}
}

emit::if_inline() {
    read
    echo "if $1; then ${REPLY}; fi"
}

self_test() (
    source /dev/stdin < <(cli_assert)

    cd "$(dirname ${BASH_SOURCE})"

    "./sample" -h \
        | "./tokenize" \
        | "./parse" \
        | "./emit" \
        | source /dev/stdin

    expected() {
        # declarations
        declare -g arg_help=""
        declare -g arg_self_test=""
        declare -g arg_fruit=""
        declare -g arg_display_args=""
        declare -g arg_header=""
        declare -g arg_help=""
        declare -g arg_run_as=""
        
        # defaults
        arg_fruit="banana"
        arg_self_test=false
        arg_help=false
        arg_display_args=false
        
        # assign variables from command line arguments
        while (( $# > 0 )); do
            case "$1" in
                '--help') arg_help=true ;;
                '--self-test') arg_self_test=true ;;
                '--fruit') arg_fruit="${2:-}"; shift ;;
                '--display-args') arg_display_args=true ;;
                '--header') arg_header="${2:-}"; shift ;;
                '-h') arg_help=true ;;
                '--run-as') arg_run_as="${2:-}"; shift ;;
                *)
                    echo "Unexpected argument '$1'."
                    exit 1
                ;;
            esac
            if (( $# > 0 )); then shift; fi
        done
        
        # required
        if [[ -z "${arg_header}" ]]; then
            echo "Missing required argument '--header'."
            exit 1
        fi
        
        # allowed values
        case "${arg_fruit}" in
            'orange') ;;
            'banana') ;;
            *)
                echo "Unexpected value '${arg_fruit}' for argument '--fruit'."
                exit 1
            ;;
        esac
    }

    diff <(declare -f expected) <(declare -f initialize) \
        | assert::pipe_eq \
            '1c1' \
            '< expected ()' \
            '---' \
            '> initialize ()' 
)

cli::load "$@"