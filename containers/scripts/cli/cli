#!/usr/bin/env bash
. $(dirname ${BASH_SOURCE})/cli.sh

: ${CLI_STAGE:=100}

readonly CLI_CMD_PATH=${CLI_CMD_PATH:="${BASH_SOURCE}"}
readonly CLI_CMD_NAME="${CLI_CMD_PATH##*/}"
readonly CLI_CMD_DIR=$(dirname ${CLI_CMD_PATH})

# paths to dsl sub-scripts (e.g. cli/dsl/help/tokenize)
readonly CLI_DIR=$(util::this_dir)
readonly CLI_DSL_DIR="${CLI_DIR}/dsl"
readonly CLI_DSL_ARGS_DIR="${CLI_DSL_DIR}/args"
readonly CLI_DSL_ARGS_TOKENIZE="${CLI_DSL_ARGS_DIR}/tokenize"
readonly CLI_DSL_ARGS_PARSE="${CLI_DSL_ARGS_DIR}/parse"
readonly CLI_DSL_LOAD="${CLI_DSL_DIR}/load"
readonly CLI_DSL_PATCH="${CLI_DSL_DIR}/patch"
readonly CLI_DSL_COMPILE="${CLI_DSL_DIR}/compile"
readonly CLI_DSL_EXECUTE="${CLI_DSL_DIR}/execute"

help() {
    echo "Command Line Interface tool."
}

entry_point() {
    return
}

pipe() {
    local stage="$1"
    local cmd="$2"

    if (( stage <= CLI_STAGE )); then
        eval "${cmd}"
    else
        while read; do echo "${REPLY}"; done
    fi
}

assert() {
    local variable=$1
    local blob=$2
    local message=$3

    if [[ ! "${variable}" == $blob ]]; then
        error "${message}"
    fi
}

error() {
    local message=$1
    echo "${message}"
    exit 1
}

main() {
    local args=()

    util::yield_args "${CLI_CMD_DIR}" "$@" \
        | pipe 0 "${CLI_DSL_ARGS_TOKENIZE}" \
        | pipe 1 "${CLI_DSL_ARGS_PARSE}" \
        | pipe 2 "${CLI_DSL_LOAD}" \
        | pipe 3 "${CLI_DSL_PATCH}" \
        | pipe 4 "${CLI_DSL_COMPILE}" \
        | while read; do args+=( "${REPLY}" ); done

    "${args}" "${args[@]:1}"
}

test() {
    local this_dir=$(util::this_dir)

    ${this_dir}/dsl/args/tokenize --self-test
    ${this_dir}/dsl/args/parse --self-test

    ${this_dir}/dsl/help/tokenize --self-test
    ${this_dir}/dsl/help/parse --self-test

    ${this_dir}/dsl/load --self-test
    ${this_dir}/dsl/patch --self-test
    ${this_dir}/dsl/compile --self-test

    #${this_dir}/cli dsl help sample -h
}

if [[ "${1-}" == '-h' ]]; then
    help
elif [[ "${1-}" == '--self-test' ]]; then
    test
else
    main "$@"
fi

# demo
# ( pwd; echo dsl; echo help; echo sample; echo -h ) \
#   | cli dsl args tokenize \
#   | cli dsl args parse \
#   | cli dsl load \
#   | cli dsl patch \
#   | cli dsl compile \
#   | (source /dev/stdin; entry_point)

# (
#     cd "${CLI_CMD_DIR}"
#     "${CLI_SOURCE_DIR}"/find/groups "$@"
# )
# exit

# readonly LOG_TAIL=5
# readonly LOG_FILE='log.txt'

# cli::probe_for_script() {
#     local parts=( "$@" )

#     local path='.'
#     for i in "${parts[@]}"; do
#         next_path="${path}/${i}"

#         if [[ -d "${next_path}" ]]; then
#             path="${next_path}"

#         elif [[ -f "${next_path}.sh" ]]; then
#             path="${next_path}.sh"

#         else
#             break
#         fi
#     done

#     echo "${path}"
# }

# util::is_set() {
#     declare -p $1 >/dev/null 2>&1
# }

# util::main() {
#     # shell opt
#     cli::opts::set_fail_if_command_fails
#     cli::opts::set_fail_on_unset_expansion

#     shopt -s extglob
#     shopt -s globstar

#     # if stderr is tty, point it at a log file instead. This way, 
#     # stdout can be used exclusively to report status, as opposed
#     # to interleaving status with logging spew.
#     cli::if_tty_then_redirect_to_file 2 "${LOG_FILE}"

#     # if exit with non-zero, then dump the last few lines of log
#     # messages as stdout has been reserved for operational status.
#     trap cli::on_exit EXIT

#     exit 

#     # positional arguments encode parts of the command's name
#     # e.g. '$ cmd my-dir my-cmd --my-arg myValue' -> CLI_FULLNAME=( 'my_dir' 'my_cmd' )
#     cli::declare_fullname "$@"
#     shift ${#CLI_FULLNAME[@]}

#     # source the script to define 'description', 'help', 'validate', and 'main' 
#     cli::source_command "${CLI_CMD_DIR}" "${CLI_FULLNAME[@]}"
#     cli::assert_is_function 'main'
#     cli::assert_is_function 'help'
#     cli::assert_is_function 'description'

#     # tokenize and parse help and load the harvested metadata
#     # - declare optional variables
#     # - assign default values
#     # - publish an array of required variable names as CLI_ARGS_REQUIRED
#     cli::tokenize < <(help) \
#         | cli::parse \
#         | cli::load

#     # declare variables found in the command line
#     #   e.g. '$ cmd --my-arg myValue' -> ARG_MY_ARG='myValue'
#     # error if a variable is unknown
#     #   e.g. '$ cmd --my-bad' -> ERROR: '--my-bad' not recognized.
#     cli::declare "$@"

#     # error if a required variable is missing
#     cli::require < <(util::yield_args "${CLI_ARGS_REQUIRED[@]}")

#     # implement '--help'
#     if ${ARG_HELP}; then
#         echo "$(help)"
#         exit
#     fi

#     # implement '-t-run-as'
#     if [[ -n "${ARG_RUN_AS}" ]] && [[ "${ARG_RUN_AS}" != "$(whoami)" ]]; then
#         sudo su "${ARG_RUN_AS}" < <(printf "\"%s\" " "${BASH_SOURCE}" "$@"; echo)
#         exit
#     fi

#     # implement '--debug'
#     cli::prolog() { if $ARG_DEBUG; then cli::opts::set_debugging; fi; }
#     cli::epilog() { if $ARG_DEBUG; then cli::opts::unset_debugging; fi; }

#     # if 'validate' defined, then validate, and dump help on failures
#     if cli::is_function 'validate'; then
#         cli::prolog; validate; cli::epilog
#     fi

#     cli::prolog; main; cli::epilog
# }